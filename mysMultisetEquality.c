#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include "SFMT.h"


#define P 2147483647		//!< 2^31 - 1 = 2147483647

const long NEW_LINE = '\n';	//!< '\n' = 10
sfmt_t sfmt; 				//!< SIMD-oriented Fast Mersenne Twister

/**
 * Initilizes the Mersenne Twister with some truely random numbers,
 * generated by RANDOM.ORG along with a user defined random number.
 * Exists the program if the paramter contains a non-base 10 symbol.
 *
 * @param[in]	seed	A character string only containing values 0-9
 */
void init_mt(char *seed);

/**
 * Works as follows:
 * 	1. Generates 0xFFFF+1 random 32-bit numbers
 *	2. Maps these numbers to our field (2^31 - 1)
 *	3. Calculates a_i*x_i for i in [0..0xFFFF]
 *  4. Saves this in hashtable
 * Thus the hash table can be used to directly look-up a_i*x_i
 *
 * @param[out]	hashtable	A memory location where 0xFFFF ulongs can be stored
 * @return A random number in the field (2^31 - 1), which can be used as w
 */
unsigned long setHashtable(unsigned long *hashtable);

/**
 * Evaluates the univariate polynomial (w-h(x_1))(w-h(x_2))***(w-h(x_n)),
 * and returns the value. 
 *
 * @param[in]	content		The content of a file (each line ends with '\n')
 * @param[in]	numChar		Number of characters in content
 * @param[in]	w			Variable for f(z)
 * @param[in]	hashtable	Look-up table for a_i*x_i
 * @return	Value of (w-h(x_1))(w-h(x_2))***(w-h(x_n))
 */
unsigned long evalPoly(	const char *content,
						const long numChar,
						const unsigned long w,
						const unsigned long *hashtable);


/**
 * Prints 'Yes' if X and Y represent the same multiset of lines.
 * 'No' otherwise. Under the assumption that a line consists of
 * at most 80 characters, and each character is represented by
 * at most 16 bits, so each element in the multiset is represented
 * by at most b = 80*16 = 1280 bits and a multiset contains at most
 * n <= 2^24 lines this algorithm outputs correctly with probability
 * 1-2^-12.
 *
 * @param[in]	argc	The number of command line arguments
 * @param[in]	argv	A pointer to an array of string where:
 *		There must be exactly 3 arguments where:
 *			-- The first argument is data-file-1 (X)
 *			-- The second argument is data-file-2 (Y)
 *			-- A user seed in base 10
 * @return Exit code 0 on success, 1 otherwise
 */
int main(int argc, char *argv[]) {
	FILE *fp1, *fp2;			//!< file pointers
	long fSize;					//!< file size (in bytes)
	long numChar;				//!< number of chars in file
	char *buffer1, *buffer2;	//!< buffer with the whole file
	unsigned long *hashtable;	//!< mapping from 2^16 to Fp
	unsigned long w;			//!< used to evaulate polynomial
	unsigned long f1, f2;		//!< fingerprint of file 1 and 2
	
	/* Map from 2^16 to the field (2^31 - 1) */
	hashtable = malloc(sizeof(unsigned long)*0xFFFF);
		
	/* INIT Mersenne Twister */
	init_mt(argv[3]);
	/* Initialize the hash table and set w */
	w = setHashtable(hashtable);
    
	/* Open first file */
	if((fp1 = fopen(argv[1], "rb")) == NULL) {
		fprintf(stderr, "Cannot open data-file-1\n");
		exit(1);
	}

	/* Open second file */
	if((fp2 = fopen(argv [2], "rb")) == NULL) {
		fprintf(stderr, "Cannot open data-file-2\n");
		exit(1);
	}
	
	/* Get the file size (Assume they are equal) */
	fseek(fp1, 0, SEEK_END);
	fSize = ftell(fp1);
	numChar = fSize/sizeof(char)+1;
	rewind(fp1);
	
	/* Read both files to maximize the I/O performance */
	buffer1 = (char *) malloc(sizeof(char)*fSize);
	if(fread(buffer1, 1, fSize, fp1) != fSize) {
		fprintf(stderr, "Could not read data-file-1\n");
		exit(1);
	}
	
	buffer2 = (char *) malloc(sizeof(char)*fSize);
	if(fread(buffer2, 1, fSize, fp2) != fSize) {
		fprintf(stderr, "Could not read data-file-1\n");
		exit(1);
	}
	
	/* Close data files (We are done with them!) */
	fclose(fp1);
	fclose(fp2);
	
	/* Fingerprint of data-file-1 */
	f1 = evalPoly(buffer1, numChar, w, hashtable);
	/* Fingerprint of data-file-1 */
	f2 = evalPoly(buffer2, numChar, w, hashtable);

	// If they are distinct - we belive it
	if(f1-f2 != 0) {
		printf("No");
		return 0;
	}
	// Otherwise it might be a false positive
	// and we make another run to decrease
	// the probability for a flase positive
	// (with a new set of a's and w)
	w = setHashtable(hashtable);
	/* Fingerprint of data-file-1 */
	f1 = evalPoly(buffer1, numChar, w, hashtable);
	/* Fingerprint of data-file-1 */
	f2 = evalPoly(buffer2, numChar, w, hashtable);
	
	/* Print the final result */
	printf((f1-f2==0) ? "Yes" : "No");
	
	/* Cleanup */
	free(buffer1);
	free(buffer2);

	return 0;
}

inline void init_mt(char *seed) {
	char *pEnd; //!< Used to check if user seed is parsable
	/* Seed from 
	 * http://www.random.org/integers/?num=9&min=1&max=1000000000&col=9&base=16&format=plain&rnd=date.2014-05-01
	 */
	// Seed the MT using 9 random integers and 1 from user input
	uint32_t init[10] =	{	0x012d661f, 0x399ba1e1, 0x01d033e9,
							0x24ab21da, 0x3a1b142b, 0x21109a50,
							0x20d005a4, 0x35215de9, 0x091c98f1};
	// Parse user input
	init[9] = strtol(seed, &pEnd, 10);
	// Check if all was parsed
	if(pEnd[0] != '\0') {
		fprintf(stderr, "Could not convert user seed to an integer ('%c' is not in base 10)\n", pEnd[0]);
		exit(1);
	}
    // Init SFMT
    sfmt_init_by_array(&sfmt, init, 10);
}

unsigned long setHashtable(unsigned long *hashtable) {
	uint32_t *rand = malloc(sizeof(uint32_t)*(0xFFFF+1));
    // Init rand with 65536 (0xFFFF+1) random numbers
    // For all a's and one for w
    // Note: This might not be in our field
    sfmt_fill_array32(&sfmt, rand, 0xFFFF+1);
    
    // Compute a_i*x_i for all i
    // Due to the pigeon hole principle, for
    // n > 2^16 > 6.5*10^4 we would need to
    // do this multiplication at least once
    // anyway - So lets do it while the
    // memory is aligned
    for(int i = 0; i < 0xFFFF; i++) {
    	// a_i = rand[i] % P
    	// x = i
    	hashtable[i] = ((rand[i] % P) * i) % P;
    }

    return rand[0xFFFF];
}

inline unsigned long evalPoly(const char *content, const long numChar, const unsigned long w, const unsigned long *hashtable) {
	unsigned long val = 1;	// Value of the polynomial
	unsigned long h = 0;	// Accumulated value of h
	unsigned int c1, c2;	// Temp. character 1 and 2
	unsigned int tmp;		// Concatanation of c1 and c2
	int i;					// Index variable
	
	
	// Run through the content
	for(i = 0; i <= numChar; i += 2) {
		c1 = content[i] & 0xFF;
		c2 = content[i+1] & 0xFF;
		if(c1 != NEW_LINE && c2 != NEW_LINE) {
			// Extract the next 16 bits
			tmp = (c1 << 8) | c2;
			h += hashtable[tmp];
		} else {
			if(c2 == NEW_LINE) {
				// Take the last 8 bits
				h += hashtable[c1];
			} else {
				// c2 is the first character in the next element
				i--;
			}
			// h(x) is now fully calculated
			// Note that w-h is within our field
			val = ((w-h) * val) % P;
			h = 0;
			continue;
		}
	}	
	return val;
}
